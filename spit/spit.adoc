= spit(1)
Stuart Inglis, Ph.D.
:doctype: manpage
:man manual: spit manual
:man source: spit 1.2
:page-layout: base

== NAME

spit - Stu's powerful I/O tester

== SYNOPSIS

spit [ _OPTIONS_ ] ... _DEVICE(S)_ ... _COMMANDS_...

== DESCRIPTION

spit(1) performs various I/O tests. The range of tests includes:

* reading, writing, forwards, backwards, in stripes, back/forth, subsampling
* time based tests, LBA coverage tests, limited number of position tests
* sequential, random, mostly sequential
* multiple measurements per position, output of median/max values
* variable IOs in flight and steps
* static and variable block sizes
* multiple threads (with an AIO context per thread)
* multiple commands
* analysis of the underlying block devices for amplification measure
* verification of writes
* statistical output, min/max/mean/median/9s/and more
* test patterns for readahead busting
* *spit -h* to get a lot of example commands

== SIMPLE EXAMPLE

spit [OPTIONS] -f _device_ -c _commands_

e.g.
  *spit -f /dev/sda -c rzs1k1024*

== DEVICE(S)
 *-f device*::
   Specific a single block device (e.g. -f /dev/ram0)

 *-F prefix*::
   The filesystem filename prefix for filesystem tests (e.g. -F testprefix -j 32). *-F* is an alternative to *-f* and conflicts with it. Choose *-f* or *-F prefix*.

 *-I filename*::
   Specific a file that contains a list of device names (e.g. -I devices.txt). The *devices.txt* file contains one device per line. To process 200 block devices at once, create devices.txt with 200 lines.
   e.g. *spit -I devices -c rs1k1024* will start 200 threads, one per device, and run the same command on them. Note in this case the starting position is not specified so each drive will start at a random location. Adding *z* will start each job from position zero.

 *-O filename*::
   Specifies a list of raw devices, matched with the *-f* option shows
   device read/write amplification. (e.g. -f /dev/md0 -O underlyingdevices.txt)

== OPTIONS
 *-h*::
   Displays a myriad of testing commands

 *-G size*::
   Limit the positions to a maximum of *size* GB (e.g. -G 32). Without a suffix the units are in GB. Optional suffixes include: GiB, TiB, TB, PiB, PB.


 *-B filename*::
   The benchmarking file that has the per second read/write speed and IOPs

 *-P filename*::
   All positions with their size and timing and read/write actions are output. This file can be used by *spitchecker* to verify the positions between run.s
   
 *-t s*::
   Limit the execution to *s* seconds (e.g. -t 30)

 *-T s*::
   Hard exit(-1) execution if spit is still running after *s* seconds.

 *-M options*::
   Output MySQL options per test. (e.g. -M iotype=write,opsize=64,iopattern=rand,qd=128,devicestate=burst,degraded=0,k=10,m=2,encryption=none,checksum=crc32c,cache=1,precondition=GI20000)

 *-N options*::
   Output MySQL options per machine/type. (e.g. -N os=centos,version=1.2.59,machine=wow,blockdevice=lsiraid)

 *-P filename*::
   Save position information to *filename*. The positions file contains the device, offset, size, random seed, start time, end time, latency, and more.

 *-v*::
   Verify writes by reading and checking. The positions can also be written using the global *P filename* command, then verified with *spitchecker*

== COMMANDS

A command is a single contiguous string. Spaces are ignored if the
entire string is quoted. An example of a command string may look like:

*spit -f /dev/device -c rk64P1000s3*

Note: For readability it is possible to pass in the command options surround by double quotes.

*spit -f /dev/device -c "r z s1 k1024 q1"*

The command options are described below:

 *r*::
   Performs reads

 *w*::
   Performs writes

 *m*::
   Double the number of test positions, and add a read operation to the position of any previous write operation. Since the number of positions is usually much more than the QD there is no in-flight issue. *m* can be combined with reading/writing or anymix. (e.g. ws0m)

 *pN*::
   Set the read/write ratio to *N*. (e.g. p0 is write only, p1 is read only, p0.75 is 75% reads)

 *Glow-high*::
   Limit the position range to *low* to *high* GB. (e.g. G2-3).

 *G_*::
   The range can be specified with the syntax *G_* which will split the G ranges evenly between all threads (no thread contention). e.g. *spit -f /dev/device -c rzs1j32* will create 32 threads, all accessing the same block device, all reading the same positions. To partition the LBA space between threads use the *G_* option, which will first divide the LBA range by the number of threads.
 
 *j N*::
   Multiply the number of commands (*-c*) by N. (e.g. -j 8). *-c rs0j8* will create 8 threads, each performing random reads. Each thread will be seeded with a unique random value so the random positions will not be the same. 

 *kN* or *klowBS-highBS*::
   Block size or _lowblocksize_ to _highblocksize_ range. (e.g. k4-128). The hypen as a range will pick a value between the low and high range, in multiples of a 4KiB block size. The range with a colon (e.g. k4-128) will only pick values that are also powers of 2.

 *n*::
   Use random positions with replacement 

 *N*::
   Add the maximum block size to all positions

 *qN*::
   Queue depth

 *JN*::
   Jumble/shuffle *N* values at a time. (e.g. s1J10 randomises each 10 values)

 *jN*::
   Scales up the number of jobs. Similar to the global *j* command.

 *RN*::
   Seed

 *sN*::
   number of contiguous sequence regions. *s0* means random, *s1* means
   a single linear stream, *s32* means 32 contigous stream.

 *s0.x*::
   Between s0 (random) and s1 (linear stream) there is a range of s0.0 up to s1. The s0.1 will be lineared by with a probability of 0.1 the location will be randomised.

 *sN-maxSizeInKiB*::
   Specify the number of continuous sequence regions, include the maximum
   continuous length in KiB. e.g. s32-1024 makes 32 contiguous regions with a
   maximum size of 1024 KiB (1 MiB).

 *u*::
   Generate pairs of writes followed by reads with unique seeds. Combined with
   multiple threads and G_ (LBA thread separation) and QD=1, this enables POSIX w/r testing.

 *z*::
   Start sequential positions from block 0

 *Zn*::
   Start sequential positions from block *n*

 *D*::
   Turn off O_DIRECT device access mode. e.g. required for ZFS and similar file systems.

=== Scale/position commands

 *Pn*::
   Limit the number of positions to *n*

 *xn*::
   Cover each of the LBA positions *n* times. e.g. -c rs1x1 will cover the LBA range and will ignore the time duration commands.

=== Timing commands

 *Bn*::
   Before the command starts, wait *n* seconds

 *Wn*::
   Wait for *n* seconds between iterations

 *Tn*::
   Limits the thread/command to *n* seconds

 *Xn*::
   Instead of time based, iterate until the positions have been processed
   *n* times.

== Benchmarking

=== Sequential reads / writes

In the following commands, replace *r* with *w* for writes.

*spit* -f /dev/device -c rk64

  Performs a single thread/job that performs reads, with 64 KiB reads

*spit* -f /dev/device -c rk64 -j 32

  Create 32 threads, with a single contigous read inside each thread

*spit* -f /dev/device -c r32k64

  Create a single threads, break the device into 32 contiguous regions


=== Random read / writes

*spit* -f /dev/device -c rs0

  Performs a single thread/job, random 4KiB reads

*spit* -f /dev/device -c rs0 -j 32

  Creates 32 threads, reads random 4KiB reads

*spit* -f /dev/device -c rs0 -j 32 -G1

  Creates 32 threads, reads randomly 4KiB reads, limited to first 1 GB.
  For devices with cache these operations should be cached.

*spit* -f /dev/device -c rP10000

  Read from the first 10,000 positions (4 KiB) blocks in a device.


=== Mixing reads/writes

*spit* -f /dev/device -c mP10000 -c rk64

  Two threads, one reading/write metadata to 10,000 positions. Another
  thread performing sequential reads.

*spit* -f /dev/device -c w -c r

  Two threads, both sequential, one reading, one writing.

*spit* -f /dev/device -c ws0 -c rs0

  Two threads, both random, one reading, one writing.

*spit* -f /dev/device -c ws1G0-100 -c ws0G100-200

  On a 200 GB device perform linear writes in the first half and
  random writes on the second half.


== EXIT STATUS

*0*::
  Success.

*non-zero*::
  Failure (syntax of usage error).
  
== BUGS

Bugs will be rewarded by choc fish... in person :)

== AFFILIATIONS

Department of Computer Science, University of Waikato, New Zealand.

Visit us, it's a lovely campus and a great place to live.